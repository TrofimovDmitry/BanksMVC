1. Логично разбить скрипты и представление на 2 части (держать логику и представление в одном файле не лучшая практика) (~\Views\Banks\Index.cshtml)
2. enum необходимо вынести из контроллера в отдельную папку
3. BanksController: 84 строка – object здесь не уместен, лучше использовать generic. (https://learn.microsoft.com/ru-ru/dotnet/csharp/programming-guide/types/boxing-and-unboxing )
4. В методах запросов к базе данных не привязывайтесь к индексам, завтра мы добавим новый столбец – и ваш код сломается. Обращайтесь по имени свойств к reader. В целом все методы следует не привязывать к каким-либо конкретным классам или запросам, старайтесь по максимуму использовать абстракции, ваш код станет более гибким и менее связанным относительно других классов. Свойства можно получить следующим образом (где T - generic)
foreach (var prop in typeof(T).GetProperties())
5. BanksController: 59 – для чего такая конструкция? Не нужно преобразовывать enum в число, чтобы далее использовать его не по назначению (6)
(int)Enum.Parse(typeof(Banks), bankName)
Не лучше ли будет?
var bank = Enum.Parse<Banks>(bankName);
или более правильный вариант
if (!Enum.TryParse<Banks>(bankName, out var bank))
{
   throw new Exception(“Не случилось”);
}
...
 
6. BanksController: 91 – здесь идет привязка к индексам Enum, т.е. добавив новый элемент перечисления – логика сломается. А была бы сущность типа Banks, а не int – этого получилось бы избежать. Здесь же предполагалось, что вы покажите реализацию паттерна «Strategy» одним из доступных способов. Или, как минимум, вынесите метод, реализующий логику подсчета вносимых сумм в банки, отдельно в Manager, Service и т.д.
7. BanksController: 136,159 – допустимо, но хорошей практикой будет использование для этих целей middleware в контексте asp net core.
8. По тестам, вместо повторения одних и тех же кусков кода логично вместо атрибута [Fact] использовать атрибуты [Theory]/[ClassData]/[MemberData], а входные данные вынести отдельно.
